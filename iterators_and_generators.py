
"""
Марк лутц - объект считается итерируемым, если он является физически сохраненной последовательстью в памяти, либо объектом который генерирует по одному эелементу за раз
в контексте итерационной операции

"""

"""
# Ромельо python'к вершинам мастерсва'
когда pyhton проходит по объекту, он ищет __iter__, если не находит, то чищет_getitem__ начиная поиск элементов по индексу 0 ,
если нет таких методов, то изключение object is not iterable  # Ромельо python'к вершинам мастерсва'

итеририуемый объект - объект, от которого встроенная функция iter может получить итератор.
"""


def func():
    yield 1


print(func())  # generated object
c = func()
print(next(c))  # 1


# генератор нужно испольховать там, где неизвестно конечное количество объектов, иначе работает медленее.
# Генератор возвращает generated object, когда он доходит до конца, нужно его снова вызывать
# итератор описывает правила перебора. генератор - подвид генератора.
# генератор является для себя и итератором

s = 'ABC'
it = iter(s)  # получить итератор итер
while True:
    try:
        print(next(it))  # начинает итерацию с индекса 0
    except StopIteration:
        del it
        break

import re
import reprlib

RE_WORD = re.compile(r'\w+')


class Sentence:
    def __init__(self, text):
        self.text = text
        self.words = RE_WORD.findall(text)

    def __repr__(self):
        return 'Sentence(%s)' % reprlib.repr(self.text)

    def __iter__(self):
        for word in self.words:
            yield word


# ниже генератор

"""
Основные особенности, присущие всем функциям генераторам:

любая функция, содержащая ключевое слово yield, является функцией генератором
когда вызывается функция генератор, то она не возвращает единственное значение, как это делает обыкновенная функция
функция генератор всегда возвращает объект типа generator, который поддерживает протокол итератора
Разница между yield и оператором return заключается в том, что для ключевого слова yield состояние выполнения генератора приостанавливается и локальные переменные сохраняются. При следующем вызове метода генератора __next__() функция возобновляет свое выполнение из той точки, из которой завершила в прошлый раз.

Генератор является итератором, поэтому он обладает всеми его особенностями:

нельзя получить длину генератора функцией len()
нельзя распечатать элементы генератора функцией print() без предварительной распаковки
у генератора нельзя получить элемент по индексу
после итерации по генератору он становится пустым
"""
def generate_ints():
    yield 1
    yield 2
    return 3
    yield 4

for num in generate_ints():
    print(num)
"""
Основные особенности, присущие всем функциям генераторам:

любая функция, содержащая ключевое слово yield, является функцией генератором
когда вызывается функция генератор, то она не возвращает единственное значение, как это делает обыкновенная функция
функция генератор всегда возвращает объект типа generator, который поддерживает протокол итератора
Разница между yield и оператором return заключается в том, что для ключевого слова yield состояние выполнения генератора приостанавливается и локальные переменные сохраняются. При следующем вызове метода генератора __next__() функция возобновляет свое выполнение из той точки, из которой завершила в прошлый раз.

Генератор является итератором, поэтому он обладает всеми его особенностями:

нельзя получить длину генератора функцией len()
нельзя распечатать элементы генератора функцией print() без предварительной распаковки
у генератора нельзя получить элемент по индексу
после итерации по генератору он становится пустым
"""

def double_inputs():
    while True:
        x = yield  # Получение внешнего значения
        yield x * 2  # Производство удвоенного значения

doubler = double_inputs()
next(doubler)  # Нужно сначала "запустить" корутину
print(doubler.send(10))  # Отправляем 10 в корутину, она удваивает и возвращает 20
print(doubler.send(-5))  # Отправляем -5, она удваивает и возвращает -10

"""
в функцию генератор можно еще передавать значения
"""


RE_WORD = re.compile(r'\w+')


class Sentence:
    def __init__(self, text):
        self.text = text

    def __repr__(self):
        return f'Sentence({reprlib.repr(self.text)})'

    def __iter__(self):
        for match in RE_WORD.finditer(self.text):
            yield match.group()

# объект генератор и генератор коллекций
